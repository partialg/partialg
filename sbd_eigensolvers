"""
Sridhara-based Block Diagonalization
----
DESCRIPTION: provides block-eigensolver function for sparse and dense matrices, adapted from Sridhara formula for the roots of a 2nd-order polynomial for scalars.
AUTHOR: Dennis Lima (June 2025).
PUBLISHED: July 2025
APPLICATION: matrix compression to estimate eigenvalues faster than numpy LU eigensolver, and some Variational Quantum Eigensolvers.
Copyright: CC BY 4.0.
----

To import functions from this python file, download the partial_algebra folder, move it to your working directory, then use:
from partial_algebra.sbd_eigensolvers import SBD_eigvals, SBD_eigbranch

----


#===================================================
# Example usage 1 ==================================
#===================================================

def Compare(sample_size=100, T0=0, N0=1):
    ''' EXAMPLE USAGE OF SBD FUNCTION
    sample_size <int>: number of random matrices to test
    T0 <float>: factor to be added to initial matrix and subtracted from eigenvalues to improve quality.
    N0 <float>: factor to divide initial matrix and multiply eigenvalues to improve quality.

    '''
    for i in range(sample_size):
        try:
            M = np.random.rand(8,8)                # Generating random matrix M
            M = M.dot(M.conjugate().transpose() )  # Making M Hermitian
            M = M/M.trace()/N0 + T0*np.eye(8)                     # Normalizing M
            #
            L = SBD_eigvals(M)                     # Block-eigensolving M
            #
            # Eigensolving M and its blocks for comparison
            E1 = (np.sort( np.abs( list( np.linalg.eigvals(L[0]) ) + list( np.linalg.eigvals(L[1]) )  ) ) - T0 ) *N0 
            E2 = (np.sort( np.linalg.eigvals( M ) ) - T0) *N0
            #
            from matplotlib import pyplot as plt
            plt.bar(range(len(E1)), E1/E2, alpha=0.4, color='blue')
            #
            plt.ylim(0.1, 5)
            plt.xlim(-0.5, len(E1)-0.5)
            #
            plt.ylabel('Ratio of eigenvalues')
            plt.xlabel('Position of eigenvalue')
            plt.title('Ratio distribution for spectrum of (8,8)-sized random matrices')
            #
        except:
            continue
    #
    plt.hlines(y=1, xmin=-5, xmax= len(E1)+5, color='black', label='Best values')
    plt.legend()
    plt.show()

Compare(sample_size=100, T0=0, N0=1)


#===================================================
# Example usage 2 ==================================
#===================================================

# Quality correction factors
T0 = 0
N0 = 1

# Preparing Hermitian matrix
M = np.random.rand(8,8)                # Generating random matrix M
M = M.dot(M.conjugate().transpose() )  # Making M Hermitian
M = M/np.trace(M)/N0 + T0*np.eye(8)    # Normalizing M

# Generating branch of block-eigenvalues.
block_eigenvalue_branch = SBD_eigbranch(M, block_index='000', )
block_eigenvalue_branch


"""




# Start of code

import numpy as np
import scipy as sp
from sympy import factorint #Used to count number of factors of 2

import matplotlib.pyplot as plt         # For usage example only
import time                             # For time measurement 


def EYE(n, sparse=False):
    if sparse == False:
        return np.eye(n)
    else:
        return sp.sparse.eye(n)

def INV(a, sparse=False):
    if sparse == False:
        return np.linalg.inv(a)
    else:
        return sp.sparse.linalg.inv(a)

def EIG(a, sparse=False, which='SM'):
    ''' 
    which <str>: SM or LM for smallest magnitude and largest magnitude.
    '''
    if sparse == False:
        return np.linalg.eig(a)
    else:
        return sp.sparse.linalg.eigs( a, k=a.shape[0]-2 , which=which)


def ExactSrt(a):
    """Eigensolver way to compute matrix square roots. Not available for sparse matrices.
    Availed for comparison purpose only. Not needed in the main algorithm.
    """
    e, v = np.linalg.eig( a )
    e    = np.array(e, dtype=complex )
    return v.dot( np.dot( np.diag( np.sqrt( e ) ), v.inv()) )


def NS_sqrt(a, max_it = 6, k_pow = 1/4, sparse=False):
    "Newton-Schulz matrix root expansion."
    A     = a.trace()**k_pow * EYE(a.shape[0], sparse=sparse)   # Initial guess
    for i in range(max_it):
        A = 0.5*(A + a @ INV(A, sparse=sparse) )
    return A


# Slice blocks of matrix =====================
def Block(a, nrow=2, sparse=False):
    ''' Splits matrix M into nrow*nrow blocks. Blocks have equal size if len(M)/nrow is integer.
    #
    INPUT  <np.array> : sparse matrix not allowed.
    OUTPUT <tuple(np.array)>
    '''
    #
    if sparse == True:
        M = a.toarray()
    else:
        M = a.copy()
    #
    rows   = np.array_split(M, indices_or_sections=nrow, axis=0 ) 
    #
    blocks = []
    for row in rows:
        blocks.append( 
            np.array_split(row, indices_or_sections=nrow, axis=1 )
        )
    #
    if sparse == True:
        m = []
        for i in range(len(blocks)):
            row = []
            for j in range(len(blocks[0]) ):
                row.append( sp.sparse.csr_array( blocks[i][j] )   )
            m.append(row)
        return tuple(m) 
    else:
        return tuple(blocks)


#==============================================

def SBD_eigvals(a, sqrt= NS_sqrt, sparse=False):
    ''' Matrix-polynomial root via Sridhara-based Block Diagonalization method.
    PARAMETERS
        a            : matrix to take block-Bhaskara of. Accepts np.array or scipy sparse array.
        srt <np.array>: function to compute matrix square root
    OUTPUT
        <np.array>
    '''
    blk       = Block(a, nrow=2, sparse=sparse)
    A, C      = blk[0][0], blk[0][1]
    D, B      = blk[1][0], blk[1][1]
    #
    t = A + B        # Block-trace    
    #
    try:             # Block-determinant with inverse of A
        A_ = INV(A, sparse=sparse)
        d  = A.dot(B) - A.dot(D.dot( A_.dot(C) ))
    except:          # Without inverse of A
        print('Exception')
        d  = A.dot(B) - D.dot(C)
    #
    term = sqrt( t.dot(t) - 4*d, sparse=sparse )
    L0   = 0.5*(t - term)
    L1   = 0.5*(t + term)
    #
    return (L0, L1)


def SBD_unitary_vector(v, normalize=False, sparse=False):
    ''' Sridhara-based Block Diagonalization compressor for unitary vectors
    INPUTS
        v <array-like>  : numpy dense 2D array or scipy sparse 2D array with shape (n,1) for any integer n>0.
        normalize <bool>: if True, normalizes compressed vector to recover unitarity, otherwise returns raw compressed vector.
        sparse <bool>   : if True, uses sparse methods, otherwise uses dense array methods.
    OUTPUT
        eigenvalue : if close to 1, compression had good quality.
        eigenvector: array-like of shape (n/2,2) where (n,2) is the shape of the input vector v.
    NOTES
        Can be used with any vector, but will only search for eigenvector whose compressed density matrix eigenvalue (given vector v) is close to 1.
        Can only compress vector with even dimension.
        Intended for use with unitary vectors, especially for state compression in quantum computing for quantum chemistry.
        May fail due to poor invertibility of blocks of density matrix.
    '''
    #
    if v.shape[0] %2 != 0:
        raise Warning('Shape is not even. Returning None.')
        return None
    #
    M   = v.dot(v.T.conjugate())
    L1  = SBD_eigvals(M, sparse=sparse)[1]
    #
    if sparse == False:
        L1 = sp.sparse.coo_array( L1 )        
    #
    e, v = sp.sparse.linalg.eigs( L1, k=1, sigma=1 )
    #
    if normalize == True:
        v = v/np.abs( np.sqrt( v.T.conjugate().dot( v ) ) )
    #
    if sparse == True:
        return e, v
    else:
        return e, np.array( v )



def SBD_eigbranch(M, block_index='0', sparse=False, only_even=False ):
    ''' SBD_eigbranch finds eigenleaf of block-eigenvalue tree.
    block_index <int>: index of block-diagonal matrix (its length is the number of compressions).
    only_even <bool>: True ensures output only has elements with 2*n compressions, where n is the list index, as required by some VQE algorithms. 
                      False ensures output is full branch of compressed matrices.
    '''
    #
    t0 = time.perf_counter()
    
    if 2**(len( block_index )-1) < M.shape[0]:
        L = [M, ]
        t = [0, ]
        for i in range( len(block_index) ):
            L.append( SBD_eigvals(L[-1], sparse=sparse)[ int(block_index[i]) ] )    # Block-eigensolving
            t.append( (time.perf_counter()-t0)/60. )
        #
        if only_even == True:
            L = [L[i] for i in range(0,len(L),2)]
            t = [t[i] for i in range(0, len(t), 2)]
    else:
        print(f'ABORTED: block_index is {int( len( block_index ) - np.log2(len(M)) )  } indices too large.')
        L = None
        #
    report = {'time':t}    # Time is in minutes
    return L, report





# END OF CODE
#==============================================
