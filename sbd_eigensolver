"""
Sridhara-based Block Diagonalization
----
DESCRIPTION: provides block-eigensolver function for matrices, adapted from Sridhara formula for the roots of a 2nd-order polynomial for scalars.
AUTHOR: Dennis Lima (June 2025).
APPLICATION: fast, lossy matrix compression [lossily] preserving eigenvalues.
Copyright: CC BY 4.0.
----

To import functions from this python file, download the artial_algebra folder, change your directory to the parent folder, then use:
from partial_algebra.sbd import SBD_eigvals

----


#===================================================
# Example usage 1 ==================================
#===================================================

def Compare(sample_size=100, T0=0, N0=1):
    ''' EXAMPLE USAGE OF SBD FUNCTION
    sample_size <int>: number of random matrices to test
    T0 <float>: factor to be added to initial matrix and subtracted from eigenvalues to improve quality.
    N0 <float>: factor to divide initial matrix and multiply eigenvalues to improve quality.

    '''
    for i in range(sample_size):
        try:
            M = np.random.rand(8,8)                # Generating random matrix M
            M = M.dot(M.conjugate().transpose() )  # Making M Hermitian
            M = M/M.trace()/N0 + T0*np.eye(8)                     # Normalizing M
            #
            L = SBD_eigvals(M)                     # Block-eigensolving M
            #
            # Eigensolving M and its blocks for comparison
            E1 = (np.sort( np.abs( list( np.linalg.eigvals(L[0]) ) + list( np.linalg.eigvals(L[1]) )  ) ) - T0 ) *N0 
            E2 = (np.sort( np.linalg.eigvals( M ) ) - T0) *N0
            #
            from matplotlib import pyplot as plt
            plt.bar(range(len(E1)), E1/E2, alpha=0.4, color='blue')
            #
            plt.ylim(0.1, 5)
            plt.xlim(-0.5, len(E1)-0.5)
            #
            plt.ylabel('Ratio of eigenvalues')
            plt.xlabel('Position of eigenvalue')
            plt.title('Ratio distribution for spectrum of (8,8)-sized random matrices')
            #
        except:
            continue
    #
    plt.hlines(y=1, xmin=-5, xmax= len(E1)+5, color='black', label='Best values')
    plt.legend()
    plt.show()

Compare(sample_size=100, T0=0, N0=1)


#===================================================
# Example usage 2 ==================================
#===================================================

def SBD_eigbranch(M, block_index='000'):
    ''' SBD_eigbranch finds eigenleaf of block-eigenvalue tree.
    block_index <int> index of block-diagonal matrix (its length is the number of compressions).
    '''
    if 2**(len( block_index )-1) < len(M):
        L = [M, ]
        for i in range( len(block_index) ):
            L.append( SBD_eigvals(L[-1])[ int(block_index[i]) ] )    # Block-eigensolving M and selecting ith block-diagonal
        #
    else:
        print(f'ABORTED: block_index is {int( len( block_index ) - np.log2(len(M)) )  } indices too large.')
        L = None
        #
    return L

# Quality correction factors
T0 = 0
N0 = 1

# Preparing Hermitian matrix
M = np.random.rand(8,8)                # Generating random matrix M
M = M.dot(M.conjugate().transpose() )  # Making M Hermitian
M = M/np.trace(M)/N0 + T0*np.eye(8)    # Normalizing M

# Generating branch of block-eigenvalues.
block_eigenvalue_branch = SBD_eigbranch(M, block_index='000')
block_eigenvalue_branch


"""




# Start of code

import numpy as np
import scipy as sp
from sympy import factorint #Used to count number of factors of 2

import matplotlib.pyplot as plt         # For usage example only



def EYE(n, sparse=False):
    if sparse == False:
        return np.eye(n)
    else:
        return sp.sparse.eye((n,n))




def ExactSrt(a):
    "Eigensolver way to compute matrix square roots."
    #trc = np.trace(a)
    e, v = np.linalg.eig( a )
    e    = np.array(e, dtype=complex )
    return v.dot( np.dot( np.diag( np.sqrt( e ) ), v.inv()) )


def NS_sqrt(a, max_it = 6, k_pow = 1/4, sparse=False):
    "Newton-Schulz matrix root expansion."
    A     = a.trace()**k_pow * EYE(a.shape[0], sparse=sparse)   # Initial guess
    for i in range(max_it):
        A = 0.5*(A + a @ A.inv() )
    return A


# Slice blocks of matrix =====================
def Block(M, nrow=2, to_sparse=False):
    ''' Splits matrix M into nrow*nrow blocks. Blocks have equal size if len(M)/nrow is integer.
    #
    INPUT  <np.array> : sparse matrix not allowed.
    OUTPUT <tuple(np.array)>
    '''
    #
    rows   = np.array_split(M, indices_or_sections=nrow, axis=0 ) 
    #
    blocks = []
    for row in rows:
        blocks.append( 
            np.array_split(row, indices_or_sections=nrow, axis=1 )
        )
    #
    return tuple(blocks)


#==============================================

def SBD_eigvals(a, sqrt= NS_sqrt, sparse=False):
    ''' Matrix-polynomial root via Sridhara-based Block Diagonalization method.
    PARAMETERS
        a            : matrix to take block-Bhaskara of. Accepts np.array or scipy sparse array.
        srt <np.array>: function to compute matrix square root
    OUTPUT
        <np.array>
    '''
    blk       = Block(a, nrow=2)
    A, C      = blk[0][0], blk[0][1]
    D, B      = blk[1][0], blk[1][1]
    #
    t = A + B        # Block-trace    
    #
    try:             # Block-determinant with inverse of A
        A_ = A.inv()
        d  = A.dot(B) - A.dot(D.dot( A_.dot(C) ))
    except:          # Without inverse of A
        print('Exception')
        d  = A.dot(B) - D.dot(C)
    #
    term = sqrt( t.dot(t) - 4*d )
    L0   = 0.5*(t - term)
    L1   = 0.5*(t + term)
    #
    return (L0, L1)

# END OF CODE
#==============================================



